using System.Collections.Generic;
using System.Data;
using System.Linq;
using TableTranslator.Model;
using TableTranslator.Model.ColumnConfigurations;

namespace TableTranslator.Engines
{
    internal class SimpleTranslationEngine : TranslationEngine
    {
        internal override DataTable BuildDataTableStructure(InitializedTranslation translation)
        {
            var dataTable = new DataTable(translation.TranslationSettings.TranslationName);

            if (translation.TranslationSettings.IdentityColumnConfiguration != null)
            {
                var column = translation.TranslationSettings.IdentityColumnConfiguration.GenerateIdentityColumn();
                column.ColumnName = BuildFullColumnName(column.ColumnName, translation);
                dataTable.Columns.Add(column);
                dataTable.PrimaryKey = new[] { column };
            }
            foreach (var colConfig in translation.ColumnConfigurations.OrderBy(x => x.Ordinal))
            {
                dataTable.Columns.Add(BuildDataColumn(translation, colConfig));
            }
            return dataTable;
        }

        internal override DataTable FillDataTable<T>(InitializedTranslation translation, IEnumerable<T> data)
        {
            var dataTable = translation.Structures[this.Name].Clone();
            dataTable.TableNewRow += AssignTableNewRowEvent(translation);
            if (data == null) return dataTable;
            
            foreach (var x in data)
            {
                /* ReSharper disable once CompareNonConstrainedGenericWithNull
                I have Jon Skeet's express permission to ignore this warning :) (http://stackoverflow.com/questions/5340817/what-should-i-do-about-possible-compare-of-value-type-with-null) */
                if (x == null) continue;

                var row = dataTable.NewRow();
                foreach (var colConfig in translation.ColumnConfigurations)
                {
                    row[BuildFullColumnName(colConfig.ColumnName, translation)] = GetColumnValue(x, colConfig);
                }
                dataTable.Rows.Add(row);
            }

            return dataTable;
        }

        private static DataTableNewRowEventHandler AssignTableNewRowEvent(TranslationBase translation)
        {
            if (translation.TranslationSettings.IdentityColumnConfiguration == null || translation.TranslationSettings.IdentityColumnConfiguration.IsAutoGenerated)
            {
                return null;
            }

            return (sender, args) =>
            {
                var table = ((DataTable) sender);
                var rowCount = table.Rows.Count;
                var columnName = BuildFullColumnName(translation.TranslationSettings.IdentityColumnConfiguration.ColumnName, translation);
                var previousValue = rowCount > 0
                    ? table.Rows[table.Rows.Count - 1][columnName]
                    : null;
                args.Row[columnName] = translation.TranslationSettings.IdentityColumnConfiguration.GetValue(previousValue);
            };
        }

        internal override object GetColumnValue<T>(T data, NonIdentityColumnConfiguration colConfig)
        {
            return colConfig.GetValueFromObject(data) ?? colConfig.NullReplacement;
        }
    }
}